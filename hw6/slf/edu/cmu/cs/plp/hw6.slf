/*
 * A Formalization of the Simply Typed Lambda Calculus in SASyLF
 *
 * Author: Jonathan Aldrich
 * Modifications by Sam Estep
 *
 * This file defines the simply typed lambda calculus with an implicit representation of
 * contexts, and proves type safety.
 *
 * HW6: Add two constructs to the language syntax:
 *
 * | ?b
 * | if e then e else e
 * | rec x : tau = e[x]
 *
 * You modeled the dynamic semantics for both of these in HW3, so you
 * should be able to just copy those small-step rules into here, making
 * the necessary changes to correct any feedback you got on your HW3
 * submission, and to account (syntactically, not semantically) for the
 * fact that "x" is now typed in "rec". If you have questions then
 * please ask on Piazza.
 *
 * You haven't already modeled the static semantics for these
 * constructs, so you'll need to do that. You may need to add one
 * additional case to our syntax for types ("tau"), and extend the
 * "value" judgment as necessary. Then, fix the proofs of progress and
 * preservation.
 */

package edu.cmu.cs.plp;

module hw6 provides

module Boolean = org.sasylf.util.Boolean

terminals fn unit in value stepsorvalue T F if then else bool rec isaboolval

/************************ SYNTAX **************************************/

syntax

b = Boolean.b ::= T | F

e ::= fn x : tau => e[x]
 | x
 | e e
 | "(" ")"
 | ?b
 | if e then e else e
 | rec x : tau = e[x]

/************************************************************
 * EXERCISE 2: ADD THE SYNTAX FOR IF/THEN/ELSE AND REC HERE *
 ************************************************************/

tau ::= unit
 | tau -> tau
 | bool

Gamma ::= *
      |   Gamma, x : tau

/************************ JUDGMENTS **************************************/

judgment value: e value

--------------- val-unit
"(" ")" value

--------------------------- val-fn
fn x : tau => e1[x] value

-------- val-bool
?b value

judgment reduce: e -> e

e1 -> e1'
------------------- c-app-l
e1 e2 -> e1' e2

e1 value
e2 -> e2'
------------------- c-app-r
(e1 e2) -> (e1 e2')

e2 value
---------------------------------- r-app
(fn x : tau => e[x]) e2 -> e[e2]

e1 -> e1'
----------------------------------------------- c-if-cond
if e1 then e2 else e3 -> if e1' then e2 else e3

--------------------------- r-if-true
if ?T then e1 else e2 -> e1

--------------------------- r-if-false
if ?F then e1 else e2 -> e2

------------------------------------------- r-rec
rec x : tau = e[x] -> e[rec x : tau = e[x]]

/******************************************************************
 * EXERCISE 2: ADD EVALUATION RULES FOR IF/THEN/ELSE AND REC HERE *
 ******************************************************************/

judgment has-type: Gamma |- e : tau
assumes Gamma

-------------------------- t-unit
Gamma |- "("")" : unit

------------------------- t-var
Gamma, x:tau |- x : tau

Gamma, x1:tau |- e[x1] : tau'
--------------------------------------------- t-fn
Gamma |- fn x : tau => e[x] : tau -> tau'

Gamma |- e1 : tau' -> tau
Gamma |- e2 : tau'
---------------------------------- t-app
Gamma |- e1 e2 : tau

------------------- t-bool
Gamma |- ?b : bool



Gamma |- e1 : bool
Gamma |- e2 : tau'
Gamma |- e3 : tau'
------------------------------------- t-if-then-else
Gamma |- if e1 then e2 else e3 : tau'

Gamma, x : tau |- e[x] : tau
--------------------------------- t-rec
Gamma |- rec x : tau = e[x] : tau

/**************************************************************
 * EXERCISE 2: ADD TYPING RULES FOR IF/THEN/ELSE AND REC HERE *
 **************************************************************/

judgment stepsorvalue: e stepsorvalue

e value
--------------- stepsorvalue-value
e stepsorvalue

e -> e'
--------------- stepsorvalue-steps
e stepsorvalue


judgment isaboolval: e isaboolval

-------------------- isaboolval
?b isaboolval

/************************ THEOREMS **************************************/

/************************ PROGRESS **************************************/

/******************************************************************
 * EXERCISE 2: FIX PROGRESS TO ADD CASES FOR IF/THEN/ELSE AND REC *
 ******************************************************************/

lemma boolcanonical:
    forall d1 : * |- e : bool forall d2 : e value exists e isaboolval.

    proof by case analysis on d2:
        case rule
            --------------- val-unit
            _: ("("")") value
        is
            proof by contradiction on d1
        end case

        case rule
            --------------- val-fn
            _: (fn x : tau0 => e0[x]) value
        is
            proof by contradiction on d1
        end case

        case rule
            --------------- val-bool
            _: (? b0) value
        is
            proof by rule isaboolval
        end case
    end case analysis
end lemma

theorem progress : forall dt : * |- e : tau exists e stepsorvalue.

dsv : e stepsorvalue by induction on dt :
    case rule
        --------------- t-bool
        d1: * |- (? b0) : bool
        where e := ? b0 and tau := bool
    is
        d2: ? b0 value by rule val-bool
        d3: e stepsorvalue by rule stepsorvalue-value on d2
    end case

    case rule
        d1: * |- e0 : bool
        d2: * |- e1 : tau0
        d3: * |- e2 : tau0
        --------------------------------------- t-if-then-else
        d4: * |- (if e0 then e1 else e2) : tau0
        where e := if e0 then e1 else e2 and tau := tau0
    is
        d5: e0 stepsorvalue by induction hypothesis on d1

        proof by case analysis on d5:
            case rule
                d6: e0 value
                --------------- stepsorvalue-value
                d7: e0 stepsorvalue
            is
                d8: e0 isaboolval by lemma boolcanonical on d1, d6
                
                proof by case analysis on d8:
                    case rule
                        --------------- isaboolval
                        d9: (? b0) isaboolval
                        where e0 := ? b0
                    is
                        proof by case analysis on b0:

                            case T is
                                d10: if e0 then e1 else e2 -> e1 by rule r-if-true
                                proof by rule stepsorvalue-steps on d10
                            end case

                            case F is
                                d11: if e0 then e1 else e2 -> e2 by rule r-if-false
                                proof by rule stepsorvalue-steps on d11
                            end case

                        end case analysis
                    end case
                end case analysis
            end case

            case rule
                d20: e0 -> e0'
                --------------- stepsorvalue-steps
                d21: e0 stepsorvalue
            is
                d22: if e0 then e1 else e2 -> if e0' then e1 else e2 by rule c-if-cond on d20
                proof by rule stepsorvalue-steps on d22
            end case
        end case analysis
    end case

    case rule
        d2: (*, x : tau') |- e0[x] : tau'
        ------------------------------------ t-rec
        d3: * |- (rec x : tau' = e0[x]) : tau'
        where e := rec x : tau' = e0[x]
    is
        d4: rec x : tau' = e0[x] -> e0[rec x : tau' = e0[x]] by rule r-rec
        d5: rec x : tau' = e0[x] stepsorvalue by rule stepsorvalue-steps on d4
    end case


case rule

    -------------------------- t-unit
    dut : * |- "("")" : unit
    where e := "("")" and tau := unit

is

    dv : e value by rule val-unit
    dsv : "("")" stepsorvalue by rule stepsorvalue-value on dv

end case

// case t-var impossible - conclusion doesn't unify with dt


case rule

    dext: *, x:tau'' |- e'[x] : tau'
    ------------------------------------------------- t-fn
    dfnt: * |- fn x : tau'' => e'[x] : tau'' -> tau'
    where e := fn x : tau'' => e'[x] and tau := tau'' -> tau'

is

    dv : fn x : tau'' => e'[x] value by rule val-fn
    dsv : fn x : tau'' => e'[x] stepsorvalue by rule stepsorvalue-value on dv

end case

case rule

    dp1t: (*) |- e1 : tau' -> tau
    dp2t: (*) |- e2 : tau'
    ---------------------------------- t-app
    dappt: (*) |- (e1 e2) : tau
    where e := e1 e2

is

    dp1sv: e1 stepsorvalue by induction hypothesis on dp1t
    dp2sv: e2 stepsorvalue by induction hypothesis on dp2t

    dsv : e stepsorvalue by case analysis on dp1sv :

    case rule

        dp1v : e1 value
        ---------------------- stepsorvalue-value
        dp1sv' : e1 stepsorvalue

    is

        dsv : e stepsorvalue by case analysis on dp2sv :

        case rule

            dp2v : e2 value
            ---------------------- stepsorvalue-value
            dp2sv' : e2 stepsorvalue

        is

            dsv : e stepsorvalue by case analysis on dp1t :
                case rule
                    d1: * |- e0 : bool
                    d2: * |- e3 : (tau' -> tau)
                    d3: * |- e4 : (tau' -> tau)
                    --------------- t-if-then-else
                    d4: * |- (if e0 then e3 else e4) : (tau' -> tau)
                    where e1 := if e0 then e3 else e4
                is
                    proof by contradiction on dp1v
                end case

                case rule
                    _: (*, x : (tau' -> tau)) |- e0[x] : (tau' -> tau)
                    --------------- t-rec
                    _: * |- (rec x : (tau' -> tau) = e0[x]) : (tau' -> tau)
                is
                    proof by contradiction on dp1v
                end case

            case rule

                dpp1t' : *, x:tau' |- e1'[x] : tau
                ---------------------------------------------------- t-fn
                dp1t' : * |- fn x : tau' => e1'[x] : tau' -> tau
                where e1 := fn x : tau' => e1'[x]

            is

                ds : (fn x : tau' => e1'[x]) e2 -> e1'[e2] by rule r-app on dp2v
                dsv : e stepsorvalue by rule stepsorvalue-steps on ds

            end case

            case rule

                dp1t1' : (*) |- e11 : tau'' -> (tau' -> tau)
                dp1t2' : (*) |- e12 : tau''
                --------------------------------------------- t-app
                tp1t' : (*) |- e11 e12 : tau' -> tau
                where e1 := e11 e12

            is
                dsv : e stepsorvalue by case analysis on dp1v :

                end case analysis

            end case

            // other cases don't unify with conclusion

            end case analysis

        end case

        case rule

            dp2s : e2 -> e2'
            ---------------- stepsorvalue-steps
            dp2sv' :  e2 stepsorvalue

        is

            ds : e1 e2 -> e1 e2' by rule c-app-r on dp1v, dp2s
            dsv : e1 e2 stepsorvalue by rule stepsorvalue-steps on ds

        end case
        end case analysis
    end case

    case rule

        dp1s : e1 -> e1'
        -------------------------- stepsorvalue-steps
        dp1sv' :  e1 stepsorvalue

    is

        ds : e1 e2 -> e1' e2 by rule c-app-l on dp1s
        dsv : e1 e2 stepsorvalue by rule stepsorvalue-steps on ds

    end case
    end case analysis
end case
end induction
end theorem


/************************ PRESERVATION **************************************/

/**********************************************************************
 * EXERCISE 2: FIX PRESERVATION TO ADD CASES FOR IF/THEN/ELSE AND REC *
 **********************************************************************/

theorem preservation: forall dt: * |- e : tau forall ds: e -> e' exists * |- e' : tau.

dt' : * |- e' : tau by induction on ds:
    case rule
        --------------- r-rec
        d2: (rec x : tau0 = e0[x]) -> e0[rec x : tau0 = e0[x]]
    is
        dt' : * |- e' : tau by case analysis on dt :
            case rule
                d3: (*, x : tau) |- e0[x] : tau
                --------------- t-rec
                d4: * |- (rec x : tau = e0[x]) : tau
            is
                d5: * |- e0[rec x : tau0 = e0[x]] : tau by substitution on d3, d4
                proof by d5
            end case

        end case analysis
    end case

    case rule
        d2: e0 -> e1
        --------------- c-if-cond
        d3: (if e0 then e2 else e3) -> (if e1 then e2 else e3)
        where e := if e0 then e2 else e3
    is
        d4: * |- e0 : bool and
        d5: * |- e2 : tau' and
        d6: * |- e3 : tau' by inversion on dt
        
        d7: * |- e1 : bool by induction hypothesis on d4, d2

        proof by rule t-if-then-else on d7, d5, d6
    end case

    case rule
        --------------- r-if-true
        d2: (if (? T) then e' else e0) -> e'
        where e := if (? T) then e' else e0
    is
        d4: * |- (? T) : bool and
        d5: * |- e' : tau' and
        d6: * |- e0 : tau' by inversion on dt

        proof by d5
    end case

    case rule
        --------------- r-if-false
        _: (if (? F) then e0 else e') -> e'
    is
        d4: * |- (? F) : bool and
        d5: * |- e0 : tau' and
        d6: * |- e' : tau' by inversion on dt

        proof by d6
    end case


case rule

    d1 : e1 -> e1'
    ----------------------- c-app-l
    d2 : e1 e2 -> e1' e2
    where e := e1 e2 and e' := e1' e2

is

    dt' : * |- e' : tau by case analysis on dt :

    case rule

        d3 : * |- e1 : tau' -> tau
        d4 : * |- e2 : tau'
        ---------------------------------- t-app
        d5 : * |- (e1 e2) : tau

    is

        d6 : * |- e1' : tau' -> tau by induction hypothesis on d3, d1
        dt' : * |- e1' e2 : tau by rule t-app on d6, d4

    end case
    // other cases do not unify with form of e = (e1 e2)
    end case analysis

end case

case rule

    d1 : e1 value
    d2 : e2 -> e2'
    ----------------------- c-app-r
    d3 : e1 e2 -> e1 e2'
    where e := e1 e2 and e' := e1 e2'

is

    dt' : * |- e' : tau by case analysis on dt :

    case rule

        d4 : * |- e1 : tau' -> tau
        d5 : * |- e2 : tau'
        ---------------------------------- t-app
        d6 : * |- e1 e2 : tau

    is

        d7 : * |- e2' : tau' by induction hypothesis on d5, d2
        dt' : * |- e1 e2' : tau by rule t-app on d4, d7

    end case
    // other cases do not unify with form of e = (e1 e2)
    end case analysis

end case

case rule

    d1 : e2 value
    ------------------------------------------- r-app
    d2 : (fn x : tau' => e1[x]) e2 -> e1[e2]
    where e := (fn x : tau' => e1[x]) e2 and e' := e1[e2]

is

    dt' : * |- e' : tau by case analysis on dt :

    case rule

        d4 : * |- fn x : tau' => e1[x] : tau'' -> tau
        d5 : * |- e2 : tau''
        ---------------------------------------------------------- t-app
        d6 : * |- (fn x : tau' => e1[x]) e2 : tau

    is

        dt' : * |- e' : tau by case analysis on d4 :

        case rule

            d7: *, x:tau' |- e1[x] : tau
            ------------------------------------------------- t-fn
            d8: * |- fn x : tau' => e1[x] : tau' -> tau
            where tau'' := tau'

        is

            /** Substitution preserves typing!  No lemma to prove.
             */

            d9: * |- e1[e2] : tau by substitution on d7, d5

        end case
        // other cases do not unify with fn expression
        end case analysis

    end case
    // other cases do not unify with form of e = (e1 e2)
    end case analysis

end case
end induction
end theorem
